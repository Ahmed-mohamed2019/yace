macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖒𝖆𝖗𝖐𝖊𝖗_𝖙𝖗𝖆𝖎𝖙𝖘 {
    ($($𝓽𝓻𝓪𝓲𝓽_𝓷𝓪𝓶𝓮:ident),*) => {
        $(
            pub trait $𝓽𝓻𝓪𝓲𝓽_𝓷𝓪𝓶𝓮<𝓼𝓸𝓾𝓻𝓬𝓮_𝓽𝔂𝓹𝓮>
            where Self: From<𝓼𝓸𝓾𝓻𝓬𝓮_𝓽𝔂𝓹𝓮>
            {
            }
            impl<T: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆>
                $𝓽𝓻𝓪𝓲𝓽_𝓷𝓪𝓶𝓮<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for Option<T>
            {
            }
         )*
    }
}

// Marker traits for function arguments. Actual conversion uses Into<𝓽𝔂𝓹𝓮>.
𝖉𝖊𝖋𝖎𝖓𝖊_𝖒𝖆𝖗𝖐𝖊𝖗_𝖙𝖗𝖆𝖎𝖙𝖘! {
    𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒃𝒂𝒔𝒆_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒊𝒏𝒅𝒆𝒙_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    // There are 8ᵇⁱᵗ registers of three classes:
    //   1. 𝔞𝔩, 𝔠𝔩, 𝔡𝔩, 𝔟𝔩 — can always be used.
    //   2. 𝔞𝔥, 𝔠𝔥, 𝔡𝔥, 𝔟𝔥 — can only be used when ᵣₑₓ prefix is not used.
    //   3. 𝔰𝔭𝔩, 𝔟𝔭𝔩, 𝔰𝔦𝔩, 𝔡𝔦𝔩 — can only be used when ᵣₑₓ is specified.
    // These classes must be provided not only for 8ᵇⁱᵗ registers, but also for 16ᵇⁱᵗ, 32ᵇⁱᵗ, and 64ᵇⁱᵗ registers!
    // Othervise such forbidden instructions would be possible:
    //   𝔪𝔬𝔳𝔷𝔵 %𝔯8𝔴, %𝔞𝔥
    //   𝔪𝔬𝔳𝔷𝔵 %𝔯8𝔡, %𝔞𝔥
    //   𝔪𝔬𝔳 %𝔞𝔥, 𝔅𝔜𝔗𝔈 𝔓𝔗ℜ [%𝔯8]
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓_ₙₒᵣₑₓ,                        // 𝔞𝔥, 𝔠𝔥, 𝔡𝔥, 𝔟𝔥, and 𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_8ᵇⁱᵗₕᵢ
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓_ᵣₑₓ,                          // 𝔰𝔭𝔩, 𝔟𝔭𝔩, 𝔰𝔦𝔩, 𝔡𝔦𝔩, and 𝐠𝐩_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_8ᵇⁱᵗᵣₑₓ_ₓ86_64
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓_ᵣₑₓ_𝒂𝒏𝒅_ₙₒᵣₑₓ,                // 𝔞𝔩, 𝔠𝔩, 𝔡𝔩, 𝔟𝔩
    // Some instructions have special version when accumulator register is used.
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓_𝒏𝒐_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓,
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓_𝒏𝒐_𝒂𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓_ᵣₑₓ_𝒂𝒏𝒅_ₙₒᵣₑₓ, // 𝔞𝔩, 𝔠𝔩, 𝔡𝔩, 𝔟𝔩
    𝒊𝒔_𝒈𝒑_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    𝒊𝒔_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    𝒊𝒔_𝒙𝟖𝟕_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    𝒊𝒔_𝒎𝒂𝒔𝒌_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓,
    𝒊𝒔_𝑺𝑰𝑴𝑫_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓
}

// Marker trait to prevenct conflict for Option<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>: should it be Some(𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞{}) or None?
pub trait 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆 {}

// Address includes some values which are optional and can be unfilled. We use empty type to mark these.
// Note: we can not use just an empty tuple because then we couldn't define From trait for it.
// Note2: scale and displacement must be obtainable from 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞.  Integer types are obtainable automatically.
pub struct 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {}

// Address type is just a combination of arguments and it's mostly used to simplify interface. There are three three address types:
//   1. Legacy 8086 address — segment, base, index and [16-bit] displacement.
//      All optional except displacemet (which can be zero).
//   2. Modern 32ᵇⁱᵗ/64ᵇⁱᵗ address — segment, base, index, scale and [32-bit] displacement.
//      All optional except for scale (which can be 1 and that's default) and displacement (which can be zero).
//   3. Gather address — segment, base, index, scale and [32-bit] displacement.
//      Similar to previous one, but index is vector register and, more importantly, it's not optional.
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086
<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: Option<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
    >
    From<
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    > for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: 𝒊𝒔_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒃𝒂𝒔𝒆_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒊𝒏𝒅𝒆𝒙_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86
<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: Option<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
    >
    From<
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    >
    for 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    >
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: 𝒊𝒔_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒃𝒂𝒔𝒆_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒊𝒏𝒅𝒆𝒙_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝗌𝖼𝖺𝗅𝖾: new_address.𝗌𝖼𝖺𝗅𝖾.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒈𝒂𝒕𝒉𝒆𝒓_𝒂𝒅𝒅𝒓𝒆𝒔𝒔
<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: Option<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    pub 𝖻𝖺𝗌𝖾: Option<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

impl<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Default,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>,
        𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮: Into<𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>,
    >
    From<
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    >
    for 𝒈𝒂𝒕𝒉𝒆𝒓_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
        𝓽𝓪𝓻𝓰𝓮𝓽_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    >
where
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>: 𝒊𝒔_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>,
    Option<𝓽𝓪𝓻𝓰𝓮𝓽_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒃𝒂𝒔𝒆_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>,
    𝓽𝓪𝓻𝓰𝓮𝓽_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮:
        𝒊𝒔_𝒂𝒅𝒅𝒓𝒆𝒔𝒔_𝒊𝒏𝒅𝒆𝒙_𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓<𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>,
{
    #[inline(always)]
    fn from(
        new_address: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
            𝓼𝓸𝓾𝓻𝓬𝓮_𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
        >,
    ) -> Self {
        Self {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_address.𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into(),
            𝖻𝖺𝗌𝖾: new_address.𝖻𝖺𝗌𝖾.into(),
            𝗂𝗇𝖽𝖾𝗑: new_address.𝗂𝗇𝖽𝖾𝗑.into(),
            𝗌𝖼𝖺𝗅𝖾: new_address.𝗌𝖼𝖺𝗅𝖾.into(),
            𝖽𝗂𝗌𝗉: new_address.𝖽𝗂𝗌𝗉.into(),
        }
    }
}

#[allow(non_upper_case_globals)]
pub const 𝔞𝔡𝔡𝔯𝔢𝔰𝔰: 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
    𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞,
> = 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 {
    𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖻𝖺𝗌𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝗂𝗇𝖽𝖾𝗑: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝗌𝖼𝖺𝗅𝖾: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
    𝖽𝗂𝗌𝗉: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 {},
};

// Fluent interface requires the ability to find out type from arguments: Rust doesn't try to do complex pruning when you have
// something like 𝔞𝔡𝔡𝔯𝔢𝔰𝔰.with_base(…).with_index(…).with_disp(…).
//
// Collect all arguments into 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔 instead and then provide conversions into proper addess.
#[derive(Clone, Copy, Default, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔
<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
    pub 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    pub 𝖻𝖺𝗌𝖾: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    pub 𝗂𝗇𝖽𝖾𝗑: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    pub 𝗌𝖼𝖺𝗅𝖾: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    pub 𝖽𝗂𝗌𝗉: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒 {
    ($($𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮:ident),*) => {
        $(
            impl From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for $𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮 {
                #[inline(always)]
                fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> $𝓲𝓷𝓽_𝓽𝔂𝓹𝓮_𝓷𝓪𝓶𝓮 {
                    0
                }
            }
         )*
    }
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒!(i8, u8, i16, u16, i32, u32, i64, u64, isize, usize);

#[cfg(has_i128)]
𝖉𝖊𝖋𝖎𝖓𝖊_𝖎𝖓𝖙𝖊𝖌𝖊𝖗_𝖋𝖗𝖔𝖒!(i128, u128);

impl<𝓲𝓷𝓽_𝓽𝔂𝓹𝓮> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for core::num::Wrapping<𝓲𝓷𝓽_𝓽𝔂𝓹𝓮>
where 𝓲𝓷𝓽_𝓽𝔂𝓹𝓮: From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>
{
    #[inline(always)]
    fn from(value: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> Self {
        Self(value.into())
    }
}

impl<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮: 𝒐𝒑𝒕𝒊𝒐𝒏_𝒇𝒓𝒐𝒎_𝒖𝒏𝒇𝒊𝒍𝒍𝒆𝒅_𝒇𝒍𝒖𝒆𝒏𝒕_𝒗𝒂𝒍𝒖𝒆> From<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞> for Option<𝓪𝓻𝓫𝓲𝓽𝓻𝓪𝓻𝔂_𝓽𝔂𝓹𝓮> {
    #[inline(always)]
    fn from(_: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞) -> Self {
        None
    }
}

impl<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
{
    #[inline(always)]
    pub fn with_segment<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮>(
        self,
        new_segment: 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: new_segment,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
{
    #[inline(always)]
    pub fn with_base<𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_base: 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: new_base,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
{
    #[inline(always)]
    pub fn with_index<𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮>(
        self,
        new_index: 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: new_index,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>
{
    #[inline(always)]
    pub fn with_scale<𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>(
        self,
        new_scale: 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: new_scale,
            𝖽𝗂𝗌𝗉: self.𝖽𝗂𝗌𝗉,
        }
    }
}

impl<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮>
    𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞>
{
    #[inline(always)]
    pub fn with_disp<𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮>(
        self,
        new_disp: 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮,
    ) -> 𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
        𝒇𝒍𝒖𝒆𝒏𝒕_𝒂𝒅𝒅𝒓𝒆𝒔𝒔::<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, 𝓭𝓲𝓼𝓹_𝓽𝔂𝓹𝓮> {
            𝗌𝖾𝗀𝗆𝖾𝗇𝗍: self.𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
            𝖻𝖺𝗌𝖾: self.𝖻𝖺𝗌𝖾,
            𝗂𝗇𝖽𝖾𝗑: self.𝗂𝗇𝖽𝖾𝗑,
            𝗌𝖼𝖺𝗅𝖾: self.𝗌𝖼𝖺𝗅𝖾,
            𝖽𝗂𝗌𝗉: new_disp,
        }
    }
}

#[path = "./basic_assembler.rs"]
pub mod 𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿;
